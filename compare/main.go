package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/urfave/cli"
)

const (
	flagBaseExt = "base-ext"
	flagFromExt = "form-ext"
	flagToExt   = "to-ext"
)

func main() {
	app := cli.NewApp()
	app.Name = "gemnasium"
	app.Author = "GitLab"
	app.Email = "gl-secure@gitlab.com"

	app.Usage = "Compare vrange JSON files"
	app.ArgsUsage = "<path> [...]"

	app.Flags = []cli.Flag{
		cli.StringFlag{
			Name:  flagBaseExt,
			Usage: "Extension of base file",
			Value: ".yml",
		},
		cli.StringFlag{
			Name:  flagFromExt,
			Usage: "Extension of source file",
			Value: ".vrange.server.json",
		},
		cli.StringFlag{
			Name:  flagToExt,
			Usage: "Extension of destination file",
			Value: ".vrange.client.clean.json",
		},
	}

	app.Action = func(c *cli.Context) error {
		for _, basePath := range c.Args() {
			noExt := strings.TrimSuffix(basePath, c.String(flagBaseExt))
			fromPath := noExt + c.String(flagFromExt)
			toPath := noExt + c.String(flagToExt)

			if err := compareFiles(basePath, fromPath, toPath); err != nil {
				fmt.Fprintln(os.Stderr, basePath, err)
			}

		}
		return nil
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}

func compareFiles(basePath, fromPath, toPath string) error {
	fromDoc, err := readFile(fromPath)
	if err != nil {
		return err
	}

	toDoc, err := readFile(toPath)
	if err != nil {
		return err
	}

	if len(fromDoc) == 0 {
		return nil
	}
	affectedRange := fromDoc[0].Range

	fromMap := docToMap(fromDoc)
	toMap := docToMap(toDoc)

	diff := []string{}

	// iterate over versions of "from" document
	// and look for versions that are not "satisfied" in "to" document;
	// these versions are no longer affected
	for version, _ := range fromMap {
		if ok, _ := toMap[version]; !ok {
			// v is "satisfied" only in "from" document
			diff = append(diff, "-"+version)
		}
	}

	// iterate over versions of "to" document
	// and look for versions that are not "satisfied" in "from" document;
	// these versions are newly affected
	for version, _ := range toMap {
		if ok, _ := fromMap[version]; !ok {
			// v is "satisfied" only in "to" document
			diff = append(diff, "+"+version)
		}
	}

	if len(diff) > 0 {
		fmt.Printf("%s '%s' %s\n", basePath, affectedRange, strings.Join(diff, " "))
	}

	return nil
}

// docToMap turns a slice of record into a map
// where the key is a version is "satisfies" is true,
// and where the value is always true.
func docToMap(doc []record) map[string]bool {
	m := make(map[string]bool)
	for _, r := range doc {
		if r.Satisfies {
			m[r.Version] = true
		}
	}
	return m
}

func readFile(path string) ([]record, error) {
	r, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer r.Close()
	doc := []record{}
	err = json.NewDecoder(r).Decode(&doc)
	return doc, err
}

type record struct {
	Range     string `json:"range"`
	Version   string `json:"version"`
	Satisfies bool   `json:"satisfies"`
}
