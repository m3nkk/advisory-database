package main

import (
	"bytes"
	"encoding/json"
	"net/http"
	"strings"

	"github.com/urfave/cli"
)

const (
	paramJWT       = "jwt"
	paramServerURL = "server-url"
)

func Flags() []cli.Flag {
	return []cli.Flag{
		cli.StringFlag{
			Name:   paramJWT,
			Usage:  "JSON Web Token",
			EnvVar: "GEMNASIUM_JWT",
		},
		cli.StringFlag{
			Name:   paramServerURL,
			Usage:  "Server URL",
			EnvVar: "GEMNASIUM_SERVER_URL",
			Value:  "https://deps.sec.gitlab.com/",
		},
	}
}

func NewClient(c *cli.Context) *Client {
	return &Client{
		baseURL: strings.TrimSuffix(c.String(paramServerURL), "/"),
		jwt:     c.String(paramJWT),
	}
}

type Client struct {
	baseURL string
	jwt     string
}

type Response struct {
	Advisory
	Versions []Version `json:"versions"`
}

type PostMode int

const (
	PostModePreview PostMode = iota
	PostModePublish
)

func (c Client) Post(adv *Advisory, mode PostMode) (*Response, error) {
	// url
	var u = c.baseURL + "/api/advisories"
	if mode != PostModePublish {
		u = u + "?preview=1"
	}

	// prepare request
	payload, err := json.Marshal(adv)
	buf := bytes.NewBuffer(payload)
	req, err := http.NewRequest("POST", u, buf)
	req.Header.Set("Authorization", "Bearer "+c.jwt)

	// send request
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// process response
	switch resp.StatusCode {
	case http.StatusOK:
		var respObj = Response{}
		if err := json.NewDecoder(resp.Body).Decode(&respObj); err != nil {
			return nil, err
		}
		adv.UUID = respObj.UUID
		return &respObj, nil

	case http.StatusBadRequest, http.StatusUnprocessableEntity:
		errs := []InputError{}
		if err := json.NewDecoder(resp.Body).Decode(&errs); err != nil {
			return nil, err
		}
		return nil, InputErrors(errs)

	default:
		return nil, ErrUnexpectedStatus{resp.StatusCode, resp.Status}
	}
}
